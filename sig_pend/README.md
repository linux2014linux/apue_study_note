ctrl + \ => SIGQUIT
ctrl + c => SIGINT

sigprocmask
这个函数阻塞的含义是,发现信号并记录,等待信号不被屏蔽时再执行信号处理程序.而不是直接忽略信号.
据APUE描述,sigpromask在取消屏蔽后返回之前,信号执行信号处理程序.

demo01.cpp
当屏蔽SIGQUIT时,发送多次SIGQUIT信号后,在信号解除屏蔽时,信号处理程序只会被执行一次.
sigpending记录未决信号集合,"集合"元素唯一性原则,因此每个信号只能出现一次.

demo02.cpp
多信号设置新处理程序,被屏蔽后取消屏蔽,这些信号的信号处理函数都会被执行.

demo03.cpp
信号屏蔽期间,发送多个相同的信号,信号取消屏蔽后,信号处理程序只会执行一次.这点与APUE中的描述相同,信号处理是不会排队的.

demo04.cpp
在程序中SIGINT第一次处理期间,手动多次发送SIGINT信号,仅有第1个手动发送会被执行.猜测原因如下:
系统检测到信号后,在启动信号处理程序后会将该信号的标记为恢复为初始状态,即无效状态.所以在程序中kill执行后,SIGINT的信号处理程序就已经执行了,此时SIGINT在该进程中的状态位时无效的,当我们手动发送时会再次将其设置为有效状态.而当第2,3..次的手动发送时,此时SIGINT的状态位没有发生变化,因此也就不会反复多次执行信号处理程序了.
可以猜测系统对于信号处理是通过状态位标记的,而不是count或者队列的方式.


请在程序的正文部分处理信号(告诫)
这里所说的 “正文”，指的是：
    不在 signal() 或 sigaction() 中指定的 handler 中处理信号事件，而是在普通的程序流程能够中捕捉信号，并且处理信号。
这么做有很多好处：
    1.中断处理函数有很多限制，只能调用某些系统调用，否则可能导致上下文异常。但在正文中就不会有这个问题
    2.中断处理函数和正文之间可以视为两个不同的线程，两者之间的同步比较麻烦
    3.在正文中处理，可以实现类似于 libevent 中 EV_SIGNAL 功能——而这也是笔者正在研究的。
基本软件流程如下：
    1.使用 signal() 或 sigaction() 将需要捕获的信号设置为 SIG_IGN
    2.使用 sigprocmask() 屏蔽需要捕获的信号，同时注意将屏蔽之前的信号集保存下来（oset参数）
    3.进行相应操作（比如 epoll()）
    4.如果发现 errno 为 EINTR，那么就可以用 sigpending() 获取被屏蔽的信号集，判断需要捕获的信号是否在信号集中
    5.使用 sigprocmask() 执行一次 SIG_UNBLOCK 操作，让内核清除信号集标志
    6.回到 2，重新屏蔽信号
缺陷
    不过这个流程有一个 bug，就是信号有可能在 4 和 6 之间产生，这样的话，就捕获不到了——这还需要想想怎么处理。
参考:https://segmentfault.com/a/1190000009129036



